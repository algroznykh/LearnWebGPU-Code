struct Uniforms {
    kernel: mat3x3<f32>,
    filter_type: u32,
    frame: u32,
}

struct Storages {
    states: array<array<f32, 12>>,
}

// const SCREEN_WIDTH: i32 = 1024;
// const SCREEN_HEIGHT: i32 = 800;

// @group(0) @binding(0) var inputTexture: texture_2d<f32>;
@group(0) @binding(0) var outputTexture: texture_storage_2d<rgba8unorm, write>;
@group(0) @binding(1) var<uniform> uniforms: Uniforms;
@group(0) @binding(2) var<storage, read_write> storages: Storages;
@group(0) @binding(3) var camTexture: texture_2d<f32>;

const N = 12u;
const S = 5000.;
const B = array<i32, 12> (-332,-212,-353,566,-86,837,510,-339,373,414,-787,-712);
const W = array<array<i32, 12>, 48>(
        array<i32, 12>(-816,142,-40,142,-119,0,758,70,99,-149,-165,-141),         array<i32, 12>(-24,-1182,-67,438,267,190,358,113,191,-64,-196,-263),         array<i32, 12>(10,170,-785,-49,98,-39,733,-75,210,-161,-112,-107),         array<i32, 12>(60,-183,158,-966,352,-336,588,-356,123,-531,-364,-201),         array<i32, 12>(-11,-89,-77,-259,-2788,276,46,56,72,-28,-179,66),         array<i32, 12>(24,-43,-1,463,-452,-2262,95,59,-51,3,-222,-216),         array<i32, 12>(-162,158,-113,19,-26,-66,-1856,49,-27,-302,-99,-366),         array<i32, 12>(58,9,203,-20,-200,-76,-28,-2600,-206,29,127,358),         array<i32, 12>(-68,-222,-143,-254,-287,157,255,400,-3107,-87,373,-420),         array<i32, 12>(-59,-75,1,-464,19,82,-26,181,-187,-1802,124,-557),         array<i32, 12>(191,166,218,-398,22,131,136,552,301,-273,-1490,-123),         array<i32, 12>(188,142,283,-677,143,84,-154,-80,212,-34,-69,-1619),         array<i32, 12>(257,-95,-4,62,-3,36,29,-17,16,12,34,6),         array<i32, 12>(-79,218,-137,-68,-23,-3,63,-20,-12,-14,-1,16),         array<i32, 12>(-97,-42,211,91,-3,26,42,12,-13,-40,-5,37),         array<i32, 12>(-106,-5,-160,673,-500,177,219,41,-167,-479,-273,-478),         array<i32, 12>(-137,-144,-138,-30,402,-100,20,59,-57,-11,-16,93),         array<i32, 12>(144,174,145,84,14,128,-180,-234,-127,-221,59,192),         array<i32, 12>(8,4,6,76,-92,-343,1,-6,97,-20,-50,-41),         array<i32, 12>(-38,-38,-24,42,158,-184,-28,-130,70,-48,28,-43),         array<i32, 12>(-178,-190,-164,-131,116,-15,-154,-93,229,57,33,193),         array<i32, 12>(-52,-84,-60,-126,86,-50,32,210,-71,268,123,-203),         array<i32, 12>(213,184,191,-65,162,-25,128,445,80,69,432,-191),         array<i32, 12>(-124,-117,-125,-59,-130,-84,-42,173,261,14,5,-278),         array<i32, 12>(51,-269,-169,-412,300,-62,148,-72,219,-66,335,492),         array<i32, 12>(-157,83,-128,-397,144,-98,369,17,183,-123,392,490),         array<i32, 12>(-193,-370,35,-306,228,-5,155,49,169,-15,384,480),         array<i32, 12>(198,172,203,-172,179,92,127,183,450,-2,-66,222),         array<i32, 12>(48,39,62,169,1160,-98,174,32,-15,100,117,65),         array<i32, 12>(-36,-63,-54,279,-132,-1232,-7,130,90,37,-20,-38),         array<i32, 12>(14,54,46,-129,34,85,-480,100,-83,-325,-78,107),         array<i32, 12>(-228,-276,-217,-255,-117,-148,0,1,-156,257,164,-8),         array<i32, 12>(-27,-95,-41,-34,-35,33,150,269,-1215,-116,299,-217),         array<i32, 12>(-294,-409,-300,-267,104,-40,203,101,133,-150,368,8),         array<i32, 12>(139,154,113,27,19,274,103,150,217,174,-293,300),         array<i32, 12>(82,39,56,-211,-121,-44,-61,557,-982,-167,358,-339),         array<i32, 12>(-32,29,20,-6,-28,-19,21,1,0,21,-23,-2),         array<i32, 12>(13,-12,38,28,-47,32,-42,38,-37,-14,-27,-65),         array<i32, 12>(43,5,-36,-21,10,-21,9,15,-34,-19,-16,-30),         array<i32, 12>(528,533,528,-52,-199,-120,-6,140,211,-186,88,29),         array<i32, 12>(25,9,27,-71,30,-8,-6,73,31,44,213,-1),         array<i32, 12>(227,224,226,70,71,-43,101,100,168,-405,69,-83),         array<i32, 12>(-142,-184,-148,-169,-115,119,25,26,266,296,296,218),         array<i32, 12>(118,164,96,279,-120,98,41,30,233,-190,-124,204),         array<i32, 12>(-73,-95,-63,-89,65,-13,-5,-50,77,-51,38,87),         array<i32, 12>(-55,-71,-42,-44,29,6,38,-174,77,5,-45,112),         array<i32, 12>(148,73,136,-81,-113,12,226,133,-417,-305,226,-81),         array<i32, 12>(100,152,115,28,-229,26,-272,-200,528,-81,-102,235), );








// size of a simulation
const SW = 320;
const SH = 240 ;



fn get_xy(x : u32, y: u32) -> array<f32,N> {
    let i = x + y*SW;
    return storages.states[i];
}

fn get_xyc(x : u32, y: u32, c: u32) -> f32 {
    let i = x + y*SW;
    return storages.states[i][c];
}

fn set_xy(x : u32, y: u32, cs: array<f32, N>) {
    let i = x + y*SW;
    storages.states[i] = cs;
}

var<private> current_index: vec2i;

fn R(dx: i32, dy: i32, c: u32) -> f32 {
    let x = u32(current_index.x + dx + SW) % SW;
    let y = u32(current_index.y + dy + SH) % SH;
    let val = get_xyc(x, y, c);
    return val;
}


fn lap(c: u32) -> f32 {
    return R(1,1,c)+R(1,-1,c)+R(-1,1,c)+R(-1,-1,c) 
        +2.0* ( R(0,1,c)+R(0,-1,c)+R(1,0,c)+R(-1,0,c) ) - 12.0*R(0, 0,c);
}

fn sobx(c: u32) -> f32 {
    return R(-1, 1, c) + R(-1, 0, c)*2.0 + R(-1,-1, c)
          -R( 1, 1, c) - R( 1, 0, c)*2.0 - R( 1,-1, c);
}

fn soby(c: u32) -> f32 {
    return R( 1, 1, c)+R( 0, 1, c)*2.0+R(-1, 1, c)
          -R( 1,-1, c)-R( 0,-1, c)*2.0-R(-1,-1, c);
}


fn update(xs: array<f32, N>, ps: array<f32, N>) -> array<f32, N> {
  // for some reason, accessing consts is very expensive, hence local vars
  // see https://bugs.chromium.org/p/tint/issues/detail?id=2032
  var ws = W;
  var bs = B;



  // construct hidden state
  var hs = array<f32, 48>();
  for (var i = 0u; i<N; i++) {
    hs[i] = xs[i];
    hs[i+N] = ps[i];
    hs[i+N*2u] = abs(xs[i]);
    hs[i+N*3u] = abs(ps[i]);
  }

  // do 1x1 conv
  var y = array<f32, N>();
  for (var c = 0u; c < N; c++) {
      var val = f32(bs[c]);

      for (var i = 0u; i < 48u; i++) {
          val += hs[i] * f32(ws[i][c]);
      }
      y[c] = xs[c] + val / S;
      y[c] = clamp(y[c], -1.5, 1.5);
  }

  if (abs(y[4]) < .01) {
      return xs;
  }

  return y;
}

fn camlap(coord: vec2i) -> vec4f {
    let lapmat = mat3x3<f32>(1, 2, 1, 2, -12, 2, 1, 2, 1);
    var res = vec4f(0.);
    for (var i = -1; i<3; i++) {
    for (var j = -1; j<3; j++) {
        res += textureLoad(camTexture, coord + vec2i(i, j), 0) * lapmat[i+1][j+1];

    }}
    res /= 9.; 
    return res;
}

@compute @workgroup_size(16, 16)
fn main_image(@builtin(global_invocation_id) id: vec3u) {

    let screen_size = vec2u(textureDimensions(outputTexture));
    let fragCoord = vec2i(i32(id.x), i32(id.y) );
    var tex = camlap(fragCoord) ;

    if (id.x >= screen_size.x || id.y >= screen_size.y) { return; }

    if (id.x < u32(SW) && id.y < u32(SH)) { 
        current_index = vec2i(i32(id.x), i32(id.y));
    

        // initial state
        if (uniforms.frame == 1u) {
            var init_s = array<f32, N>();
            for (var s=0u; s<N; s++) {
                let a = .02;
                let rand = fract(sin(f32((id.x + id.y* SW) * (s+1)) / f32(SW)) * 353348.5453123) + a;
                init_s[s] = floor(rand);
            }
        set_xy(u32(current_index.x), u32(current_index.y), init_s);
        return;
        }




		var ps = array<f32, 12>(
			lap(0u) + tex.r ,
			lap(1u) + tex.g ,
			lap(2u) + tex.b ,
			lap(3u),

			sobx(4u),
			sobx(5u),
			sobx(6u),
			sobx(7u),

			soby(8u),
			soby(9u),
			soby(10u),
			soby(11u)
		);
        
        // update state
        var xs = get_xy(u32(current_index.x), u32(current_index.y));    
        var state = update(xs, ps);

        //tex *= .25;
        //for (var i = 0u; i< 4; i++) {
        //    state[i] -= sin(length(tex) - 3.14 / 2.) / 4.;
        //}
        //state[4] *= sin(length(tex)) ;


        set_xy(u32(current_index.x), u32(current_index.y), state);
    }

    // rescale buffer 
    var idxs = u32(f32(id.x) / f32(screen_size.x) * f32(SW));
    var idys = u32(f32(id.y) / f32(screen_size.y) * f32(SH));

    // output to screen
    var states = get_xy(idxs, idys);
    var xrgb = vec4(states[0], states[1], states[2], states[3]) + .5;
    var uv = vec2f(fragCoord) / vec2f(f32(screen_size.x), f32(screen_size.y));
    uv -= .5;
    uv *= 2.;

    xrgb *=  (length(xrgb)  - pow(length(uv), 2.) ) ;
    xrgb = tex;

    textureStore(
        outputTexture,
        vec2i(id.xy),
        xrgb

    );
}
