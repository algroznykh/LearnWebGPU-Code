struct Uniforms {
    kernel: mat3x3<f32>,
    filter_type: u32,
    frame: u32,
}

struct Storages {
    states: array<array<f32, 12>>,
}

// const SCREEN_WIDTH: i32 = 1024;
// const SCREEN_HEIGHT: i32 = 800;

// @group(0) @binding(0) var inputTexture: texture_2d<f32>;
@group(0) @binding(0) var outputTexture: texture_storage_2d<rgba8unorm, write>;
@group(0) @binding(1) var<uniform> uniforms: Uniforms;
@group(0) @binding(2) var<storage, read_write> storages: Storages;
@group(0) @binding(3) var camTexture: texture_2d<f32>;

const N = 12u;
const S = 5000.;
const B = array<i32, 12> (-321,-218,-334,406,-16,596,399,-309,161,436,-595,-614);
const W = array<array<i32, 12>, 48>(
        array<i32, 12>(-691,97,-31,118,-177,24,540,74,123,-49,-125,-167),         array<i32, 12>(-47,-1011,-90,363,217,187,154,111,219,32,-164,-241),         array<i32, 12>(-6,106,-668,-33,20,-1,523,-73,236,-45,-90,-143),         array<i32, 12>(6,-146,87,-813,372,-176,450,-132,214,-255,-201,-133),         array<i32, 12>(-19,-79,-59,-220,-1632,292,-14,93,82,30,-37,16),         array<i32, 12>(32,-33,6,340,-360,-1684,65,20,-80,64,-129,-247),         array<i32, 12>(-192,101,-143,-154,47,-60,-1605,51,37,-94,-128,-257),         array<i32, 12>(29,-9,126,118,-22,22,23,-1846,-112,-31,72,276),         array<i32, 12>(-84,-232,-160,-321,-346,153,266,310,-2225,48,209,-272),         array<i32, 12>(-86,-96,-48,-31,-160,47,101,147,-76,-1178,61,-347),         array<i32, 12>(187,233,189,-153,-100,79,31,399,60,-218,-1122,-166),         array<i32, 12>(181,188,274,-519,47,-31,-170,-264,161,-51,-101,-1293),         array<i32, 12>(243,-87,4,74,27,12,-19,-20,7,9,39,-24),         array<i32, 12>(-57,248,-103,-63,-21,-20,46,-16,-33,-20,25,-35),         array<i32, 12>(-69,-43,213,82,26,4,3,20,-23,-29,16,-5),         array<i32, 12>(-93,3,-123,650,-253,150,125,8,-13,-238,-230,-248),         array<i32, 12>(-47,-47,-44,-6,449,-12,-14,30,2,2,56,24),         array<i32, 12>(101,130,100,146,16,51,-155,-156,-58,-121,76,194),         array<i32, 12>(-1,-20,-1,59,23,-402,22,-20,-4,-48,-57,-49),         array<i32, 12>(-14,-15,-19,25,-22,-245,-41,-21,-70,43,-27,-1),         array<i32, 12>(-159,-167,-150,-111,144,1,-94,-92,209,16,25,250),         array<i32, 12>(6,-4,-9,-84,3,-55,-12,189,21,254,89,-139),         array<i32, 12>(208,190,202,-3,-36,41,82,217,85,32,325,-208),         array<i32, 12>(-96,-121,-96,-61,-19,-59,147,179,221,5,-24,-216),         array<i32, 12>(38,-262,-151,-498,271,-90,-22,35,235,181,447,439),         array<i32, 12>(-141,11,-126,-460,136,-124,169,113,222,134,512,462),         array<i32, 12>(-153,-338,27,-423,230,-51,-14,141,176,217,488,448),         array<i32, 12>(211,205,209,118,-5,116,313,-6,342,24,-185,126),         array<i32, 12>(30,2,26,133,678,-133,123,-83,-108,113,-4,50),         array<i32, 12>(-14,-45,-34,193,-83,-812,-7,77,28,77,40,-98),         array<i32, 12>(-22,38,12,-51,-52,38,-449,-69,24,-130,-122,-53),         array<i32, 12>(-197,-246,-189,-68,178,-155,91,-85,-201,22,86,72),         array<i32, 12>(-59,-105,-66,-63,-87,72,143,191,-561,-11,176,-103),         array<i32, 12>(-73,-79,-52,-124,-95,93,-11,65,-148,-231,234,-224),         array<i32, 12>(73,79,61,8,15,-72,-6,29,184,91,-170,235),         array<i32, 12>(-25,-75,-52,-48,112,-153,79,370,-726,-58,288,-211),         array<i32, 12>(-36,27,12,3,-33,-16,44,-12,10,5,-29,2),         array<i32, 12>(12,-43,33,42,-35,18,-22,26,-15,-29,-35,-34),         array<i32, 12>(28,22,-41,-24,3,-9,37,4,-22,-31,-25,-15),         array<i32, 12>(413,396,406,-31,-155,119,55,161,-57,-224,73,-4),         array<i32, 12>(-4,18,-8,37,-104,113,-75,77,40,-31,22,-64),         array<i32, 12>(210,222,203,188,70,29,130,108,57,-193,-20,-126),         array<i32, 12>(-114,-157,-126,-130,-149,-30,33,34,69,148,173,178),         array<i32, 12>(119,167,104,262,-211,130,-66,45,254,-11,-50,132),         array<i32, 12>(-112,-143,-108,-135,-98,-54,33,-35,11,19,77,120),         array<i32, 12>(-60,-54,-46,-66,23,21,-95,-248,-89,12,10,86),         array<i32, 12>(184,165,182,29,-98,67,136,87,-156,-194,87,-98),         array<i32, 12>(67,106,80,56,19,33,-158,-167,442,-16,-104,146), );









// size of a simulation
const SW = 320;
const SH = 240 ;



fn get_xy(x : u32, y: u32) -> array<f32,N> {
    let i = x + y*SW;
    return storages.states[i];
}

fn get_xyc(x : u32, y: u32, c: u32) -> f32 {
    let i = x + y*SW;
    return storages.states[i][c];
}

fn set_xy(x : u32, y: u32, cs: array<f32, N>) {
    let i = x + y*SW;
    storages.states[i] = cs;
}

var<private> current_index: vec2i;

fn R(dx: i32, dy: i32, c: u32) -> f32 {
    let x = u32(current_index.x + dx + SW) % SW;
    let y = u32(current_index.y + dy + SH) % SH;
    let val = get_xyc(x, y, c);
    return val;
}


fn lap(c: u32) -> f32 {
    return R(1,1,c)+R(1,-1,c)+R(-1,1,c)+R(-1,-1,c) 
        +2.0* ( R(0,1,c)+R(0,-1,c)+R(1,0,c)+R(-1,0,c) ) - 12.0*R(0, 0,c);
}

fn sobx(c: u32) -> f32 {
    return R(-1, 1, c) + R(-1, 0, c)*2.0 + R(-1,-1, c)
          -R( 1, 1, c) - R( 1, 0, c)*2.0 - R( 1,-1, c);
}

fn soby(c: u32) -> f32 {
    return R( 1, 1, c)+R( 0, 1, c)*2.0+R(-1, 1, c)
          -R( 1,-1, c)-R( 0,-1, c)*2.0-R(-1,-1, c);
}


fn update(xs: array<f32, N>, ps: array<f32, N>) -> array<f32, N> {
  // for some reason, accessing consts is very expensive, hence local vars
  // see https://bugs.chromium.org/p/tint/issues/detail?id=2032
  var ws = W;
  var bs = B;



  // construct hidden state
  var hs = array<f32, 48>();
  for (var i = 0u; i<N; i++) {
    hs[i] = xs[i];
    hs[i+N] = ps[i];
    hs[i+N*2u] = abs(xs[i]);
    hs[i+N*3u] = abs(ps[i]);
  }

  // do 1x1 conv
  var y = array<f32, N>();
  for (var c = 0u; c < N; c++) {
      var val = f32(bs[c]);

      for (var i = 0u; i < 48u; i++) {
          val += hs[i] * f32(ws[i][c]);
      }
      y[c] = xs[c] + val / S;
      y[c] = clamp(y[c], -1.5, 1.5);
  }

  if (abs(y[4]) < .01) {
      return xs;
  }

  return y;
}

fn camlap(coord: vec2i) -> vec4f {
    let lapmat = mat3x3<f32>(1, 2, 1, 2, -12, 2, 1, 2, 1);
    var res = vec4f(0.);
    for (var i = -1; i<3; i++) {
    for (var j = -1; j<3; j++) {
        res += textureLoad(camTexture, coord + vec2i(i, j), 0) * lapmat[i+1][j+1];

    }}
    // res /= 9.;
    return res;
}

@compute @workgroup_size(16, 16)
fn main_image(@builtin(global_invocation_id) id: vec3u) {

    let screen_size = vec2u(textureDimensions(outputTexture));
    let fragCoord = vec2i(i32(id.x), i32(id.y) );

    if (id.x >= screen_size.x || id.y >= screen_size.y) { return; }

    if (id.x < u32(SW) && id.y < u32(SH)) { 
        current_index = vec2i(i32(id.x), i32(id.y));
    

        // initial state
        if (uniforms.frame == 1u) {
            var init_s = array<f32, N>();
            for (var s=0u; s<N; s++) {
                let a = .02;
                let rand = fract(sin(f32((id.x + id.y* SW) * (s+1)) / f32(SW)) * 353348.5453123) + a;
                init_s[s] = floor(rand);
            }
        set_xy(u32(current_index.x), u32(current_index.y), init_s);
        return;
        }


        var tex = camlap(fragCoord) ;


		var ps = array<f32, 12>(
			lap(0u) + sin((tex.r ) * 3.14 ),
			lap(1u) + sin((tex.g  ) * 3.14 ),
			lap(2u) + sin((tex.b  ) * 3.14 ),
			lap(3u),

			sobx(4u),
			sobx(5u),
			sobx(6u),
			sobx(7u),

			soby(8u),
			soby(9u),
			soby(10u),
			soby(11u)
		);
        
        // update state
        var xs = get_xy(u32(current_index.x), u32(current_index.y));    
        var state = update(xs, ps);

        //tex *= .25;
        //for (var i = 0u; i< 4; i++) {
        //    state[i] -= sin(length(tex) - 3.14 / 2.) / 4.;
        //}
        state[4] += sin(length(tex)) ;


        set_xy(u32(current_index.x), u32(current_index.y), state);
    }

    // rescale buffer 
    var idxs = u32(f32(id.x) / f32(screen_size.x) * f32(SW));
    var idys = u32(f32(id.y) / f32(screen_size.y) * f32(SH));

    // output to screen
    var states = get_xy(idxs, idys);
    var xrgb = vec4(states[0], states[1], states[2], states[3]) + .5;
    var uv = vec2f(fragCoord) / vec2f(f32(screen_size.x), f32(screen_size.y));
    uv -= .5;
    uv *= 2.;
    // var tex = camlap(fragCoord) * .7;
    //xrgb = tex;

    xrgb *= 2. * (length(xrgb) * .5 - pow(length(uv), 2.) ); // * length(xrgb) * 2.;
    textureStore(
        outputTexture,
        vec2i(id.xy),
        xrgb

    );
}
