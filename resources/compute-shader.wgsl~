struct Uniforms {
    kernel: mat3x3<f32>,
    filter_type: u32,
    frame: u32,
}

struct Storages {
    states: array<array<f32, 12>>,
}

// const SCREEN_WIDTH: i32 = 1024;
// const SCREEN_HEIGHT: i32 = 800;

// @group(0) @binding(0) var inputTexture: texture_2d<f32>;
@group(0) @binding(0) var outputTexture: texture_storage_2d<rgba8unorm, write>;
@group(0) @binding(1) var<uniform> uniforms: Uniforms;
@group(0) @binding(2) var<storage, read_write> storages: Storages;
@group(0) @binding(3) var camTexture: texture_2d<f32>;

const N = 12u;
const S = 5000.;
const B = array<i32, 12> (-323,-207,-346,570,-112,850,515,-345,414,434,-799,-731);
const W = array<array<i32, 12>, 48>(
        array<i32, 12>(-815,146,-37,133,-124,20,766,87,77,-171,-156,-164),         array<i32, 12>(-18,-1183,-62,430,261,211,367,130,168,-85,-186,-286),         array<i32, 12>(16,174,-783,-57,94,-20,741,-58,188,-182,-102,-129),         array<i32, 12>(48,-196,147,-948,310,-336,578,-344,84,-539,-335,-234),         array<i32, 12>(-28,-91,-88,-227,-2820,298,42,64,40,-63,-164,40),         array<i32, 12>(26,-41,3,463,-445,-2271,104,64,-31,-9,-239,-238),         array<i32, 12>(-163,157,-119,34,-72,-46,-1868,75,-41,-295,-89,-401),         array<i32, 12>(47,0,188,-69,-236,-49,-46,-2619,-212,57,126,384),         array<i32, 12>(-48,-204,-113,-223,-277,138,266,382,-3132,-72,392,-417),         array<i32, 12>(-51,-77,12,-527,19,88,-53,178,-167,-1812,102,-536),         array<i32, 12>(189,172,212,-442,48,156,133,538,347,-253,-1525,-97),         array<i32, 12>(205,154,307,-616,201,48,-110,-91,229,-92,-83,-1665),         array<i32, 12>(259,-94,-2,64,4,32,37,-21,43,12,13,12),         array<i32, 12>(-81,216,-138,-65,-14,-7,69,-25,16,-12,-24,23),         array<i32, 12>(-97,-39,212,89,3,23,50,7,14,-40,-28,43),         array<i32, 12>(-107,-17,-148,677,-514,143,194,31,-165,-435,-277,-419),         array<i32, 12>(-129,-140,-128,-43,373,-150,4,53,-74,-19,17,70),         array<i32, 12>(129,155,131,99,6,143,-166,-259,-133,-204,58,178),         array<i32, 12>(15,6,15,40,-106,-344,-4,-32,74,9,-57,-38),         array<i32, 12>(-43,-36,-32,42,155,-126,-18,-133,84,-29,32,-14),         array<i32, 12>(-182,-204,-162,-162,65,-8,-158,-171,219,44,32,194),         array<i32, 12>(-63,-88,-72,-152,38,-19,-2,225,-99,308,141,-184),         array<i32, 12>(191,163,172,-105,200,14,128,451,74,99,465,-189),         array<i32, 12>(-156,-149,-156,-65,-148,-109,-47,133,284,45,5,-237),         array<i32, 12>(61,-251,-161,-374,277,-90,162,-89,236,-50,293,499),         array<i32, 12>(-150,104,-121,-358,121,-122,382,2,198,-104,351,496),         array<i32, 12>(-185,-353,43,-266,205,-31,169,33,187,4,345,487),         array<i32, 12>(214,196,223,-169,131,89,131,172,487,5,-97,245),         array<i32, 12>(62,44,69,125,1181,-112,174,24,25,135,98,88),         array<i32, 12>(-35,-61,-51,277,-126,-1239,2,134,111,25,-37,-60),         array<i32, 12>(21,61,46,-118,0,116,-495,139,-96,-317,-82,86),         array<i32, 12>(-249,-302,-245,-276,-135,-147,3,31,-154,275,132,-16),         array<i32, 12>(12,-65,2,-30,-3,17,183,239,-1201,-114,276,-217),         array<i32, 12>(-306,-415,-311,-254,67,-39,191,81,147,-120,356,68),         array<i32, 12>(120,131,93,19,-4,301,119,173,232,173,-345,310),         array<i32, 12>(80,34,52,-247,-114,8,-53,539,-983,-119,336,-376),         array<i32, 12>(-29,28,22,0,-41,-23,21,5,-22,20,-11,-10),         array<i32, 12>(14,-9,39,35,-59,32,-40,43,-60,-14,-16,-76),         array<i32, 12>(46,5,-33,-13,-2,-23,10,18,-56,-18,-3,-38),         array<i32, 12>(569,603,570,-35,-237,-102,25,119,198,-261,117,-7),         array<i32, 12>(10,-5,4,-54,-9,-15,-1,106,28,78,210,10),         array<i32, 12>(241,230,242,51,71,-27,125,82,181,-400,51,-96),         array<i32, 12>(-141,-189,-145,-202,-101,142,3,27,288,309,271,219),         array<i32, 12>(101,148,84,267,-111,86,64,-12,235,-251,-107,174),         array<i32, 12>(-95,-117,-86,-79,107,-31,-9,-91,82,-45,46,119),         array<i32, 12>(-67,-82,-55,-33,35,-14,51,-130,64,18,-25,104),         array<i32, 12>(120,41,104,-105,-91,4,210,153,-410,-274,235,-97),         array<i32, 12>(138,199,152,18,-226,43,-285,-181,509,-71,-105,237), );








// size of a simulation
const SW = 320;
const SH = 240 ;



fn get_xy(x : u32, y: u32) -> array<f32,N> {
    let i = x + y*SW;
    return storages.states[i];
}

fn get_xyc(x : u32, y: u32, c: u32) -> f32 {
    let i = x + y*SW;
    return storages.states[i][c];
}

fn set_xy(x : u32, y: u32, cs: array<f32, N>) {
    let i = x + y*SW;
    storages.states[i] = cs;
}

var<private> current_index: vec2i;

fn R(dx: i32, dy: i32, c: u32) -> f32 {
    let x = u32(current_index.x + dx + SW) % SW;
    let y = u32(current_index.y + dy + SH) % SH;
    let val = get_xyc(x, y, c);
    return val;
}


fn lap(c: u32) -> f32 {
    return R(1,1,c)+R(1,-1,c)+R(-1,1,c)+R(-1,-1,c) 
        +2.0* ( R(0,1,c)+R(0,-1,c)+R(1,0,c)+R(-1,0,c) ) - 12.0*R(0, 0,c);
}

fn sobx(c: u32) -> f32 {
    return R(-1, 1, c) + R(-1, 0, c)*2.0 + R(-1,-1, c)
          -R( 1, 1, c) - R( 1, 0, c)*2.0 - R( 1,-1, c);
}

fn soby(c: u32) -> f32 {
    return R( 1, 1, c)+R( 0, 1, c)*2.0+R(-1, 1, c)
          -R( 1,-1, c)-R( 0,-1, c)*2.0-R(-1,-1, c);
}


fn update(xs: array<f32, N>, ps: array<f32, N>) -> array<f32, N> {
  // for some reason, accessing consts is very expensive, hence local vars
  // see https://bugs.chromium.org/p/tint/issues/detail?id=2032
  var ws = W;
  var bs = B;



  // construct hidden state
  var hs = array<f32, 48>();
  for (var i = 0u; i<N; i++) {
    hs[i] = xs[i];
    hs[i+N] = ps[i];
    hs[i+N*2u] = abs(xs[i]);
    hs[i+N*3u] = abs(ps[i]);
  }

  // do 1x1 conv
  var y = array<f32, N>();
  for (var c = 0u; c < N; c++) {
      var val = f32(bs[c]);

      for (var i = 0u; i < 48u; i++) {
          val += hs[i] * f32(ws[i][c]);
      }
      y[c] = xs[c] + val / S;
      y[c] = clamp(y[c], -1.5, 1.5);
  }

  if (abs(y[4]) < .01) {
      return xs;
  }

  return y;
}

fn camlap(coord: vec2i) -> vec4f {
    let lapmat = mat3x3<f32>(1, 2, 1, 2, -12, 2, 1, 2, 1);
    var res = vec4f(0.);
    for (var i = -1; i<3; i++) {
    for (var j = -1; j<3; j++) {
        res += textureLoad(camTexture, coord + vec2i(i, j), 0) * lapmat[i+1][j+1];

    }}
    return res;
}

@compute @workgroup_size(16, 16)
fn main_image(@builtin(global_invocation_id) id: vec3u) {

    let screen_size = vec2u(textureDimensions(outputTexture));
    let fragCoord = vec2i(i32(id.x), i32(id.y) );
    var tex = camlap(fragCoord) ;

    if (id.x >= screen_size.x || id.y >= screen_size.y) { return; }

    if (id.x < u32(SW) && id.y < u32(SH)) { 
        current_index = vec2i(i32(id.x), i32(id.y));
    

        // initial state
        if (uniforms.frame == 1u) {
            var init_s = array<f32, N>();
            for (var s=0u; s<N; s++) {
                let a = .02;
                let rand = fract(sin(f32((id.x + id.y* SW) * (s+1)) / f32(SW)) * 353348.5453123) + a;
                init_s[s] = floor(rand);
            }
        set_xy(u32(current_index.x), u32(current_index.y), init_s);
        return;
        }




		var ps = array<f32, 12>(
			lap(0u) + cos((tex.r ) ),
			lap(1u) + cos((tex.g ) ),
			lap(2u) + cos((tex.b ) ),
			lap(3u),

			sobx(4u),
			sobx(5u),
			sobx(6u),
			sobx(7u),

			soby(8u),
			soby(9u),
			soby(10u),
			soby(11u)
		);
        
        // update state
        var xs = get_xy(u32(current_index.x), u32(current_index.y));    
        var state = update(xs, ps);

        //tex *= .25;
        //for (var i = 0u; i< 4; i++) {
        //    state[i] -= sin(length(tex) - 3.14 / 2.) / 4.;
        //}
        //state[4] *= sin(length(tex)) ;


        set_xy(u32(current_index.x), u32(current_index.y), state);
    }

    // rescale buffer 
    var idxs = u32(f32(id.x) / f32(screen_size.x) * f32(SW));
    var idys = u32(f32(id.y) / f32(screen_size.y) * f32(SH));

    // output to screen
    var states = get_xy(idxs, idys);
    var xrgb = vec4(states[0], states[1], states[2], states[3]) + .5;
    var uv = vec2f(fragCoord) / vec2f(f32(screen_size.x), f32(screen_size.y));
    uv -= .5;
    uv *= 2.;

    xrgb *=  (length(xrgb) / 4. - pow(length(uv), 2.) ) ;
    xrgb *= tex ;

    textureStore(
        outputTexture,
        vec2i(id.xy),
        xrgb

    );
}
