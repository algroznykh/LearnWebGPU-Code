struct Uniforms {
    kernel: mat3x3<f32>,
    filter_type: u32,
    frame: u32,
}

struct Storages {
    states: array<array<f32, 12>>,
}

// const SCREEN_WIDTH: i32 = 1024;
// const SCREEN_HEIGHT: i32 = 800;

// @group(0) @binding(0) var inputTexture: texture_2d<f32>;
@group(0) @binding(0) var outputTexture: texture_storage_2d<rgba8unorm, write>;
@group(0) @binding(1) var<uniform> uniforms: Uniforms;
@group(0) @binding(2) var<storage, read_write> storages: Storages;
@group(0) @binding(3) var camTexture: texture_2d<f32>;

const N = 12u;
const S = 5000.;
const B = array<i32, 12> (-189,-94,-198,173,-39,159,116,-82,86,185,-256,-305);
const W = array<array<i32, 12>, 48>(
        array<i32, 12>(-362,48,19,-28,-142,-28,141,20,-8,22,-77,-111),         array<i32, 12>(-43,-483,-56,78,166,52,-108,57,65,101,-102,-150),         array<i32, 12>(43,87,-343,-106,8,-20,171,-115,109,37,-73,-103),         array<i32, 12>(1,-66,38,-358,126,-141,74,-35,80,-14,-85,-59),         array<i32, 12>(34,-44,3,-75,-466,-22,64,67,-30,5,-39,24),         array<i32, 12>(-25,-57,-27,120,-44,-547,87,-52,-67,51,-8,28),         array<i32, 12>(-82,28,-88,-33,-7,-138,-568,63,3,5,58,-124),         array<i32, 12>(-10,-3,16,-10,-58,72,-60,-494,-1,36,32,101),         array<i32, 12>(-30,-75,-46,-41,-30,-19,81,-78,-646,86,-19,-32),         array<i32, 12>(-67,-111,-67,31,-48,-74,8,35,-73,-346,-8,-50),         array<i32, 12>(102,174,119,-74,-35,72,-88,134,-9,-20,-510,-100),         array<i32, 12>(31,60,70,-190,20,-25,-77,-143,47,-32,-196,-632),         array<i32, 12>(160,-72,-10,13,30,-4,-43,-24,11,12,12,-25),         array<i32, 12>(-36,165,-86,-23,-30,-15,56,-26,-26,0,3,-27),         array<i32, 12>(-73,-42,144,25,9,-10,-20,27,-27,3,7,2),         array<i32, 12>(-111,-50,-113,264,-23,57,-56,-4,-40,-37,-62,-104),         array<i32, 12>(-10,13,-7,40,212,4,-77,95,-38,9,2,34),         array<i32, 12>(13,53,18,125,14,89,-144,-83,-16,-34,4,4),         array<i32, 12>(27,51,22,123,-73,-140,-117,53,-18,-14,-15,-13),         array<i32, 12>(23,11,34,25,120,-105,45,-182,44,5,4,7),         array<i32, 12>(-71,-83,-69,-47,7,-43,-11,-3,-14,20,59,93),         array<i32, 12>(39,57,33,17,-4,12,-41,10,41,100,17,-1),         array<i32, 12>(106,88,106,53,19,-28,-13,16,81,38,227,-32),         array<i32, 12>(-27,-20,-30,6,22,54,9,76,84,-24,27,-250),         array<i32, 12>(38,-106,-57,-259,125,-23,-70,-9,38,134,173,213),         array<i32, 12>(-41,24,-48,-210,29,-26,20,18,21,83,184,212),         array<i32, 12>(-60,-169,33,-217,61,-8,-90,67,3,149,188,230),         array<i32, 12>(90,111,109,71,35,-96,102,42,69,-89,-63,-101),         array<i32, 12>(-15,-52,-22,-22,-46,21,29,65,7,-11,-9,22),         array<i32, 12>(-16,-16,-6,81,30,-141,9,-40,-62,13,122,43),         array<i32, 12>(-38,-34,-49,-23,22,26,-48,23,93,-20,-33,-52),         array<i32, 12>(3,0,8,20,35,57,20,-81,-13,-13,27,-17),         array<i32, 12>(-9,-13,-11,-1,53,-40,-6,-25,-64,-11,-14,-4),         array<i32, 12>(-49,-68,-64,-42,-14,25,2,-17,-182,6,218,-122),         array<i32, 12>(37,42,49,34,39,-39,-31,-8,102,-56,-43,23),         array<i32, 12>(-6,-60,-21,-118,99,-23,20,21,-240,30,157,-108),         array<i32, 12>(-23,2,2,9,-4,11,12,-8,0,11,-9,-1),         array<i32, 12>(-12,-27,6,34,-11,19,-24,14,-7,-32,-23,-21),         array<i32, 12>(14,12,-28,-1,2,2,9,-11,-22,-29,-15,-10),         array<i32, 12>(149,156,142,69,-16,16,27,57,21,-73,5,46),         array<i32, 12>(-15,-7,-17,40,11,-18,2,7,87,-55,-20,50),         array<i32, 12>(19,18,20,43,21,71,61,-8,-28,-25,34,-8),         array<i32, 12>(-13,-15,-11,22,-40,-7,-28,-15,28,-5,16,43),         array<i32, 12>(1,2,-2,-4,12,2,16,30,38,-14,-2,23),         array<i32, 12>(-43,-67,-41,-125,38,4,-28,9,-20,-2,46,91),         array<i32, 12>(8,-13,2,-20,-10,17,13,7,-72,14,32,76),         array<i32, 12>(147,167,147,122,-9,-39,33,92,-88,-79,45,-56),         array<i32, 12>(51,87,64,62,-12,34,-46,2,238,-47,-85,37), );











// size of a simulation
const SW = 320;
const SH = 240 ;



fn get_xy(x : u32, y: u32) -> array<f32,N> {
    let i = x + y*SW;
    return storages.states[i];
}

fn get_xyc(x : u32, y: u32, c: u32) -> f32 {
    let i = x + y*SW;
    return storages.states[i][c];
}

fn set_xy(x : u32, y: u32, cs: array<f32, N>) {
    let i = x + y*SW;
    storages.states[i] = cs;
}

var<private> current_index: vec2i;

fn R(dx: i32, dy: i32, c: u32) -> f32 {
    let x = u32(current_index.x + dx + SW) % SW;
    let y = u32(current_index.y + dy + SH) % SH;
    let val = get_xyc(x, y, c);
    return val;
}


fn lap(c: u32) -> f32 {
    return R(1,1,c)+R(1,-1,c)+R(-1,1,c)+R(-1,-1,c) 
        +2.0* ( R(0,1,c)+R(0,-1,c)+R(1,0,c)+R(-1,0,c) ) - 12.0*R(0, 0,c);
}

fn sobx(c: u32) -> f32 {
    return R(-1, 1, c) + R(-1, 0, c)*2.0 + R(-1,-1, c)
          -R( 1, 1, c) - R( 1, 0, c)*2.0 - R( 1,-1, c);
}

fn soby(c: u32) -> f32 {
    return R( 1, 1, c)+R( 0, 1, c)*2.0+R(-1, 1, c)
          -R( 1,-1, c)-R( 0,-1, c)*2.0-R(-1,-1, c);
}


fn update(xs: array<f32, N>, ps: array<f32, N>) -> array<f32, N> {
  // for some reason, accessing consts is very expensive, hence local vars
  // see https://bugs.chromium.org/p/tint/issues/detail?id=2032
  var ws = W;
  var bs = B;



  // construct hidden state
  var hs = array<f32, 48>();
  for (var i = 0u; i<N; i++) {
    hs[i] = xs[i];
    hs[i+N] = ps[i];
    hs[i+N*2u] = abs(xs[i]);
    hs[i+N*3u] = abs(ps[i]);
  }

  // do 1x1 conv
  var y = array<f32, N>();
  for (var c = 0u; c < N; c++) {
      var val = f32(bs[c]);

      for (var i = 0u; i < 48u; i++) {
          val += hs[i] * f32(ws[i][c]);
      }
      y[c] = xs[c] + val / S;
      y[c] = clamp(y[c], -1.5, 1.5);
  }

  if (abs(y[4]) < .01) {
      return xs;
  }

  return y;
}

fn camlap(coord: vec2i) -> vec4f {
    let lapmat = mat3x3<f32>(1, 2, 1, 2, -12, 2, 1, 2, 1);
    var res = vec4f(0.);
    for (var i = -1; i<3; i++) {
    for (var j = -1; j<3; j++) {
        res += textureLoad(camTexture, coord + vec2i(i, j), 0) * lapmat[i+1][j+1];

    }}
    // res /= 9.;
    return res;
}

@compute @workgroup_size(16, 16)
fn main_image(@builtin(global_invocation_id) id: vec3u) {

    let screen_size = vec2u(textureDimensions(outputTexture));
    let fragCoord = vec2i(i32(id.x), i32(id.y) );

    if (id.x >= screen_size.x || id.y >= screen_size.y) { return; }

    if (id.x < u32(SW) && id.y < u32(SH)) { 
        current_index = vec2i(i32(id.x), i32(id.y));
    

        // initial state
        if (uniforms.frame == 1u) {
            var init_s = array<f32, N>();
            for (var s=0u; s<N; s++) {
                let a = .02;
                let rand = fract(sin(f32((id.x + id.y* SW) * (s+1)) / f32(SW)) * 353348.5453123) + a;
                init_s[s] = floor(rand);
            }
        set_xy(u32(current_index.x), u32(current_index.y), init_s);
        return;
        }


        var tex = camlap(fragCoord) ;


		var ps = array<f32, 12>(
			lap(0u) + sin((tex.r - .5) * 3.14),
			lap(1u) + sin((tex.g - .5 ) * 3.14 ),
			lap(2u) + sin((tex.b - .5 ) * 3.14 ),
			lap(3u),

			sobx(4u),
			sobx(5u),
			sobx(6u),
			sobx(7u),

			soby(8u),
			soby(9u),
			soby(10u),
			soby(11u)
		);
        
        // update state
        var xs = get_xy(u32(current_index.x), u32(current_index.y));    
        var state = update(xs, ps);

        //tex *= .25;
        //for (var i = 0u; i< 4; i++) {
        //    state[i] -= sin(length(tex) - 3.14 / 2.) / 4.;
        //}
        // state[4] += tex.r / 4. ;


        set_xy(u32(current_index.x), u32(current_index.y), state);
    }

    // rescale buffer 
    var idxs = u32(f32(id.x) / f32(screen_size.x) * f32(SW));
    var idys = u32(f32(id.y) / f32(screen_size.y) * f32(SH));

    // output to screen
    var states = get_xy(idxs, idys);
    var xrgb = vec4(states[0], states[1], states[2], states[3]) + .5;
    var uv = vec2f(fragCoord) / vec2f(f32(screen_size.x), f32(screen_size.y));
    uv -= .5;
    uv *= 2.;
    // var tex = camlap(fragCoord) * .7;
    //xrgb = tex;

    xrgb *= (1. - pow(length(uv), 2.) );
    textureStore(
        outputTexture,
        vec2i(id.xy),
        xrgb

    );
}
