struct Uniforms {
    kernel: mat3x3<f32>,
    filter_type: u32,
    frame: u32,
}

struct Storages {
    states: array<array<f32, 12>>,
}

// const SCREEN_WIDTH: i32 = 1024;
// const SCREEN_HEIGHT: i32 = 800;

// @group(0) @binding(0) var inputTexture: texture_2d<f32>;
@group(0) @binding(0) var outputTexture: texture_storage_2d<rgba8unorm, write>;
@group(0) @binding(1) var<uniform> uniforms: Uniforms;
@group(0) @binding(2) var<storage, read_write> storages: Storages;
@group(0) @binding(3) var camTexture: texture_2d<f32>;

// const N = 12u;
// const S = 5000.;
// const B = array<i32, 12> (-241,-221,-199,-91,-104,86,157,-79,-60,-82,-172,202);
// const W = array<array<i32, 12>, 48>(
//         array<i32, 12>(-684,-42,33,-11,52,375,159,45,92,-38,-105,330),         array<i32, 12>(-102,-412,12,30,143,249,138,132,74,-69,-2,203),         array<i32, 12>(87,38,-293,-173,415,-26,-130,141,132,81,80,-100),         array<i32, 12>(105,66,9,-547,-92,-163,-221,173,-42,-211,122,-122),         array<i32, 12>(-9,-97,-82,76,-1052,4,-276,34,-109,42,-96,22),         array<i32, 12>(-11,-195,-20,283,87,-1215,-389,368,-177,-143,-67,-92),         array<i32, 12>(7,-47,44,-76,221,279,-1182,-216,-226,152,-57,-268),         array<i32, 12>(-156,-175,51,104,203,16,108,-1341,94,91,-203,28),         array<i32, 12>(101,82,31,-56,-6,69,49,182,-1085,138,-10,-78),         array<i32, 12>(-294,-227,-53,-151,21,-39,72,-66,111,-880,-70,-108),         array<i32, 12>(-243,-243,-4,-19,41,-78,-79,210,12,-22,-1107,245),         array<i32, 12>(-245,-224,-40,95,108,-91,423,-174,60,-172,-51,-812),         array<i32, 12>(-4,-81,21,34,41,49,27,2,-28,-86,-67,58),         array<i32, 12>(80,156,-74,99,-16,27,25,-54,-22,-38,-40,6),         array<i32, 12>(18,74,474,215,-124,10,-56,88,52,-22,34,-115),         array<i32, 12>(-286,-220,-39,535,-139,-50,13,169,-209,-61,314,-351),         array<i32, 12>(-13,2,3,-18,-239,39,-74,-20,72,-101,33,49),         array<i32, 12>(93,75,11,9,70,119,-140,33,-7,140,5,58),         array<i32, 12>(114,74,33,-5,-142,2,-253,-129,-6,-104,-119,164),         array<i32, 12>(193,97,-9,45,24,193,45,200,-208,-53,-215,81),         array<i32, 12>(188,127,57,16,24,-24,-96,-46,-33,-90,-241,124),         array<i32, 12>(-196,-161,-23,192,-97,-74,111,-27,32,-143,27,-158),         array<i32, 12>(82,83,11,-5,76,46,77,-100,21,-89,-174,153),         array<i32, 12>(22,33,17,-55,41,-106,-41,-50,65,-88,158,-1),         array<i32, 12>(-18,-129,-60,-94,91,200,-297,369,402,-363,345,-124),         array<i32, 12>(-158,53,11,-369,-44,-63,-222,257,251,-144,304,-139),         array<i32, 12>(-131,-54,220,72,-314,92,126,-134,-124,-42,-46,98),         array<i32, 12>(-53,-18,-6,-70,250,143,25,-51,210,-7,111,-187),         array<i32, 12>(-100,-82,-3,-327,320,-315,-51,71,85,242,131,-24),         array<i32, 12>(-227,-188,-20,187,-121,-131,24,39,-219,144,79,81),         array<i32, 12>(-122,-93,-44,241,203,175,154,-55,-234,94,96,-20),         array<i32, 12>(-190,26,8,-196,26,256,-35,-505,-257,-155,19,-222),         array<i32, 12>(39,-8,-15,102,-79,-280,-63,203,-145,-466,-104,-17),         array<i32, 12>(9,-14,-77,-103,40,206,-171,299,-51,601,200,3),         array<i32, 12>(663,407,-22,673,232,396,212,-262,256,-30,-167,-118),         array<i32, 12>(225,247,88,387,315,71,110,-171,-521,-78,-309,-6),         array<i32, 12>(-7,24,0,-58,18,-6,-11,-35,18,-2,-44,8),         array<i32, 12>(12,-3,7,-8,12,0,41,18,21,-18,-30,51),         array<i32, 12>(168,28,26,231,8,4,81,13,-246,4,-187,-37),         array<i32, 12>(-61,-70,-9,86,131,-113,-98,195,199,-154,184,-44),         array<i32, 12>(4,-25,-19,-76,0,-27,86,201,17,-46,-43,-52),         array<i32, 12>(-65,-50,-26,-35,-55,-21,-7,96,17,69,174,-79),         array<i32, 12>(92,121,53,35,35,167,-145,-169,98,67,-56,169),         array<i32, 12>(24,-13,-10,-82,48,147,75,66,36,84,-19,34),         array<i32, 12>(146,105,49,-20,19,150,-53,-88,-52,-17,-166,91),         array<i32, 12>(150,113,20,-24,-32,-16,-78,-50,-170,35,6,27),         array<i32, 12>(-113,-88,2,95,7,-107,-12,76,8,-48,20,-8),         array<i32, 12>(-54,-52,-46,29,-67,-39,86,43,-35,213,22,-82), );

const N = 12u;
const S = 5000.;
const B = array<i32, 12> (-248,8,-492,-478,231,365,-269,-110,340,-2,-613,-59);
const W = array<array<i32, 12>, 48>(
        array<i32, 12>(-452,-455,-265,-574,160,-232,-111,-151,234,61,283,538),         array<i32, 12>(161,-1046,-318,-612,693,-164,-256,200,2,-251,198,-415),         array<i32, 12>(-295,454,-649,-52,297,-150,440,-108,66,-368,-75,-369),         array<i32, 12>(533,154,76,-720,-250,161,-58,291,35,-131,-413,-22),         array<i32, 12>(-198,-641,-243,480,-926,-34,-346,-116,-68,67,-261,440),         array<i32, 12>(-47,-237,105,275,269,-1367,121,202,27,-166,-377,-369),         array<i32, 12>(-106,350,-99,-156,506,-39,-1369,-246,220,-7,-366,-395),         array<i32, 12>(209,-265,-99,30,31,106,-29,-1076,-59,270,217,184),         array<i32, 12>(-519,404,53,-727,-233,-327,-133,-107,-583,635,615,-99),         array<i32, 12>(208,137,187,188,36,42,-44,-193,-633,-1212,263,-262),         array<i32, 12>(333,-66,169,246,50,225,76,-88,-611,318,-694,-50),         array<i32, 12>(128,8,208,39,-278,95,401,-239,115,-35,220,-902),         array<i32, 12>(231,-150,-203,-62,-5,-62,-7,39,113,63,0,-34),         array<i32, 12>(-188,179,-78,-24,112,-84,-29,-40,-7,-12,44,40),         array<i32, 12>(-8,-23,378,25,65,105,-43,-70,-38,-33,36,-47),         array<i32, 12>(283,147,21,336,-27,-74,-37,-63,-21,72,96,-44),         array<i32, 12>(-137,-212,-25,143,273,20,-79,28,-60,24,75,93),         array<i32, 12>(55,-25,-30,39,6,364,-53,37,30,-4,-30,-1),         array<i32, 12>(-18,54,1,-47,6,34,366,4,-45,-44,-84,23),         array<i32, 12>(12,-63,-175,44,-65,-51,-69,274,11,24,5,-63),         array<i32, 12>(-83,122,39,20,-37,14,-8,3,344,71,-86,38),         array<i32, 12>(113,70,38,86,-22,-30,40,-48,-40,380,50,92),         array<i32, 12>(-106,-122,-26,38,24,49,-5,-22,-52,-89,420,14),         array<i32, 12>(48,32,79,14,10,-44,-3,105,14,123,17,291),         array<i32, 12>(-114,-49,184,313,-52,-149,99,29,8,130,441,57),         array<i32, 12>(-273,-7,-33,177,40,-20,-57,-77,85,157,259,-157),         array<i32, 12>(100,-127,-40,160,-268,-361,122,217,65,-14,419,-200),         array<i32, 12>(-202,-293,17,0,133,-209,-80,-34,97,-64,100,4),         array<i32, 12>(253,187,-70,-24,79,24,-127,463,14,190,-127,-341),         array<i32, 12>(-665,214,42,303,618,75,299,108,-319,-316,180,-330),         array<i32, 12>(219,-232,-187,229,697,264,-271,643,-467,569,696,-107),         array<i32, 12>(-202,-122,-22,-86,87,96,-237,191,-156,78,-67,-17),         array<i32, 12>(-487,27,58,276,-142,21,157,-64,98,-119,-262,-218),         array<i32, 12>(191,189,-2,-170,-26,173,-404,517,-77,173,-103,-258),         array<i32, 12>(-288,-143,-106,-208,-59,-86,-93,46,270,-257,-37,161),         array<i32, 12>(-190,102,-13,275,109,-30,213,45,-24,-109,38,43),         array<i32, 12>(-88,-2,63,39,-25,-56,3,-21,56,8,-47,35),         array<i32, 12>(83,95,-13,-36,-2,-59,7,97,-11,34,-72,-13),         array<i32, 12>(45,1,-42,-85,-77,69,134,-16,-24,-6,25,-48),         array<i32, 12>(224,211,99,-126,34,-145,114,193,185,-150,52,24),         array<i32, 12>(115,64,-23,-123,72,-43,-21,-55,57,73,124,-44),         array<i32, 12>(41,-33,33,185,-136,-63,126,-230,80,-117,-95,43),         array<i32, 12>(50,86,31,5,-131,70,-25,19,33,-103,-72,10),         array<i32, 12>(64,-49,-4,12,-30,-165,199,-132,-87,-315,44,103),         array<i32, 12>(-99,-59,-36,146,18,-117,69,58,116,-18,47,40),         array<i32, 12>(-8,-37,-1,-107,-159,-66,16,138,-204,-142,-104,-87),         array<i32, 12>(-16,-149,-28,205,-30,-105,174,-55,41,-89,-18,-139),         array<i32, 12>(-20,-39,-2,57,-137,-178,-24,-156,-130,-7,-41,96), );



// size of a simulation
const SW = 640;
const SH = 480 ;



fn get_xy(x : u32, y: u32) -> array<f32,N> {
    let i = x + y*SW;
    return storages.states[i];
}

fn get_xyc(x : u32, y: u32, c: u32) -> f32 {
    let i = x + y*SW;
    return storages.states[i][c];
}

fn set_xy(x : u32, y: u32, cs: array<f32, N>) {
    let i = x + y*SW;
    storages.states[i] = cs;
}

var<private> current_index: vec2i;

fn R(dx: i32, dy: i32, c: u32) -> f32 {
    let x = u32(current_index.x + dx + SW) % SW;
    let y = u32(current_index.y + dy + SH) % SH;
    let val = get_xyc(x, y, c);
    return val;
}


fn lap(c: u32) -> f32 {
    return R(1,1,c)+R(1,-1,c)+R(-1,1,c)+R(-1,-1,c) 
        +2.0* ( R(0,1,c)+R(0,-1,c)+R(1,0,c)+R(-1,0,c) ) - 12.0*R(0, 0,c);
}

fn update(xs: array<f32, N>, ps: array<f32, N>) -> array<f32, N> {
  // for some reason, accessing consts is very expensive, hence local vars
  // see https://bugs.chromium.org/p/tint/issues/detail?id=2032
  var ws = W;
  var bs = B;



  // construct hidden state
  var hs = array<f32, 48>();
  for (var i = 0u; i<N; i++) {
    hs[i] = xs[i];
    hs[i+N] = ps[i];
    hs[i+N*2u] = abs(xs[i]);
    hs[i+N*3u] = abs(ps[i]);
  }

  // do 1x1 conv
  var y = array<f32, N>();
  for (var c = 0u; c < N; c++) {
      var val = f32(bs[c]);

      for (var i = 0u; i < 48u; i++) {
          val += hs[i] * f32(ws[i][c]);
      }
      y[c] = xs[c] + val / S;
      y[c] = clamp(y[c], -1.5, 1.5);
  }

  if (abs(y[4]) < .01) {
      return xs;
  }

  return y;
}

fn camlap(coord: vec2i) -> vec4f {
    let lapmat = mat3x3<f32>(1, 2, 1, 2, -12, 2, 1, 2, 1);
    var res = vec4f(0.);
    for (var i = -1; i<3; i++) {
    for (var j = -1; j<3; j++) {
        res += textureLoad(camTexture, coord + vec2i(i, j), 0) * lapmat[i+1][j+1];

    }}
    res /= 8.;
    return res;
}

@compute @workgroup_size(16, 16)
fn main_image(@builtin(global_invocation_id) id: vec3u) {

    let screen_size = vec2u(textureDimensions(outputTexture));
    if (id.x >= screen_size.x || id.y >= screen_size.y) { return; }

    if (id.x < u32(SW) || id.y < u32(SH)) { 
        current_index = vec2i(i32(id.x), i32(id.y));
    

        // initial state
        if (uniforms.frame == 1u) {
            var init_s = array<f32, N>();
            for (var s=0u; s<N; s++) {
                let a = .01;
                let rand = fract(sin(f32((id.x + id.y* SW) * (s+1)) / f32(SW)) * 353348.5453123) + a;
                init_s[s] = floor(rand);
            }
        set_xy(u32(current_index.x), u32(current_index.y), init_s);
        return;
        }

        // construct perception vector
        var ps = array<f32, 12>();
        for (var i = 0u; i < N; i++) {
            ps[i] = lap(i);
        }
        
        // update state
        var xs = get_xy(u32(current_index.x), u32(current_index.y));    
        var state = update(xs, ps);

        let fragCoord = vec2i(i32(id.x), i32(id.y) );

        let tex = camlap(fragCoord);
        for (var i = 9u; i< N; i++) {
            state[i] += tex.r / 4.;
        }


        set_xy(u32(current_index.x), u32(current_index.y), state);
    }

    // rescale buffer 
    var idxs = u32(f32(id.x) / f32(screen_size.x) * f32(SW));
    var idys = u32(f32(id.y) / f32(screen_size.y) * f32(SH));

    // output to screen
    var states = get_xy(idxs, idys);
    var xrgb = vec4(states[0], states[1], states[2], states[3]) + .5;

    textureStore(
        outputTexture,
        vec2i(id.xy),
        xrgb
    );
}
